<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://koko-club.github.io</id>
    <title>Imcry</title>
    <updated>2023-02-27T07:58:19.859Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://koko-club.github.io"/>
    <link rel="self" href="https://koko-club.github.io/atom.xml"/>
    <subtitle>春风得意马蹄疾，一日看尽长安花</subtitle>
    <logo>https://koko-club.github.io/images/avatar.png</logo>
    <icon>https://koko-club.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, Imcry</rights>
    <entry>
        <title type="html"><![CDATA[欢迎来到Gridea]]></title>
        <id>https://koko-club.github.io/post/huan-ying-lai-dao-gridea/</id>
        <link href="https://koko-club.github.io/post/huan-ying-lai-dao-gridea/">
        </link>
        <updated>2023-02-27T07:06:43.000Z</updated>
        <content type="html"><![CDATA[<p>当你看到这篇文章，意味着你的眼睛是睁开的，谢谢。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[jenkins]]></title>
        <id>https://koko-club.github.io/post/jenkins/</id>
        <link href="https://koko-club.github.io/post/jenkins/">
        </link>
        <updated>2023-02-19T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="jenkins">jenkins</h1>
<h2 id="介绍">介绍</h2>
<p>Jenkins是一个开源的、提供友好操作界面的持续集成(CI)工具，起源于Hudson，主要用于持续、自动的构建/测试软件项目、监控外部任务的运行。Jenkins用Java语言编写，可在Tomcat等流行的servlet容器中运行，也可独立运行。通常与版本管理工具(SCM)、构建工具结合使用。常用的版本控制工具有SVN、GIT，构建工具有Maven、Ant、Gradle。</p>
<p>jenkins官网：https://www.jenkins.io/</p>
<h3 id="持续集成ci">持续集成CI</h3>
<p>持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91/1258343?fromModule=lemma_inlink">编译</a>，发布，自动化测试）来验证，从而尽早地发现集成错误。</p>
<p>通俗来讲持续集成就是软件开发人员提交代码以后自动化构建、发布、测试。</p>
<figure data-type="image" tabindex="1"><img src="https://koko-club.github.io/post-images/jenkins/webp.webp" alt="img" loading="lazy"></figure>
<h3 id="持续交付cd">持续交付CD</h3>
<p>CD(Continuous Delivery， 中文意思持续交付)是在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境(类生产环境)中。比如，我们完成单元测试后，可以把代码部署到连接数据库的Staging环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境。下图反应的是CI/CD 的大概工作模式。</p>
<figure data-type="image" tabindex="2"><img src="https:////upload-images.jianshu.io/upload_images/6464255-ba088ec7257062c0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img" loading="lazy"></figure>
<h2 id="部署">部署</h2>
<p>部署方式一般现在就分为二进制部署和docker(k8s)部署。</p>
<p>官网下载：https://www.jenkins.io/download/</p>
<h3 id="二进制包部署">二进制包部署</h3>
<p>jenkins本身是基于java开发，其二进制包是war文件，运行于tomcat。</p>
<p>1.部署tomcat</p>
<p>2.下载jenkins的war部署包</p>
<p>3.将包放于tomcat的webapps目录下，启动tomcat。默认8080端口访问。</p>
<h3 id="k8sdocker部署">k8s(docker)部署</h3>
<h4 id="docker部署">docker部署</h4>
<p>dockeruhb官网镜像地址：https://hub.docker.com/r/jenkins/jenkins</p>
<p>1.拉取镜像	docker pull jenkins/jenkins</p>
<p>2.在本地创建Jenkins-home目录：mkdir -p /home/jenkins_home 用于映射</p>
<p>3.启动Jenkins容器：docker run -d --name jenkins -p 8080:8080 -p 50000:50000 -v /home/jenkins_home:/var/jenkins_home jenkins/jenkins</p>
<p>​	-p 50000:50000 ，<code>这个端口映射要保持一致</code>，否则agent无法启动，agent部分主要作用就是告诉Jenkins,选择哪台节点机器去执行Pipeline代码</p>
<p>4、然后网站上输入IP:8080访问，需要输入密码，复制页面上的路径，在服务器上输入cat 路径查看密码，粘贴到输入框之后下一步就好</p>
<p>​	cat / var/jenkins_home/secrets/initialadminpassword</p>
<h4 id="k8s部署">k8s部署</h4>
<p>k8s上面一般有两种部署方式，使用yaml文件部署和helm方式部署。</p>
<h5 id="helm方式">helm方式</h5>
<p>helm方式建议使用官方镜像，这里如果用的是bitnami的镜像则建议替换成官方，我这边使用发现bitnami的jenkins有些系统配置无法持久化。</p>
<pre><code>helm repo add jenkins  https://charts.jenkins.io      
helm pull jenkins  https://charts.jenkins.io    
tar -xvf jenkins-VERSION.tar.gz
cd jenkins
vim values.yaml
#根据需求更改配置
重要的配置包括jenkins密码，svc类型，jenkins持久化存储配置（PVC）
改完以后
helm install jenkins . -n 要部署的名称空间
</code></pre>
<h5 id="yaml部署">yaml部署</h5>
<p>jenkins.yaml:</p>
<pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: jks
spec:
  replicas: 1
  selector:
    matchLabels:
      app: jks
  template:
    metadata:
      labels:
        app: jks
    spec:
      containers:
      - name: jks
        image: jenkins/jenkins:2.319.3-centos7-jdk8
        imagePullPolicy: Always
        ports:
        - containerPort: 8080
        volumeMounts:
        - name: jks-home
          mountPath: /var/jenkins_home
        - name: time-zone                            #容器内挂载点名称
          mountPath: /etc/localtime              #容器内挂载点路径，可以是文件或目录
      affinity: #这里由于jenkins镜像很大，避免删掉pod重构切换节点又要拉取数据，所以固定其节点。
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
            - matchExpressions:
              - key: kubernetes.io/hostname # 标签键名
                operator: In
                values:
                - node2 
      initContainers:
      - args:
        - -c
        - chmod 755 /var/jenkins_home &amp;&amp; chown 1000:1000 /var/jenkins_home   ### 这里将上一步所记录的权限属组进行更改
        command:
        - /bin/sh
        image: centos
        imagePullPolicy: IfNotPresent
        name: chauth
        securityContext:
          privileged: true    ###  建议开启特权模式
        volumeMounts:
        - mountPath: /var/jenkins_home      ### initc也要对次数据卷进行挂载
          name: jks-home
      volumes:
      - name: time-zone                              #数据卷名称，需要与容器内挂载点名称一致
        hostPath:
          path: /etc/localtime  
      - name: jks-home
        persistentVolumeClaim:
            claimName: jks-pvc
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: jks-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 200Gi
---
apiVersion: v1
kind: Service
metadata:
  name: jks
spec:
  selector:
    app: jks
  type: NodePort
  ports:
    - port: 8080
      targetPort: 8080
      nodePort: 32089

</code></pre>
<p>kubectl apply -f jenkins.yaml</p>
<p>部署完后访问jenkins:</p>
<figure data-type="image" tabindex="3"><img src="https://koko-club.github.io/post-images/jenkins/image-20230215154224734.png" alt="image-20230215154224734" loading="lazy"></figure>
<p>这里还是和上面一样，进入容器找到这个文件</p>
<pre><code>[root@node1 jenkins_test]# kubectl exec -it jks-698b6564fb-5692t -n k3s-test bash 
kubectl exec [POD] [COMMAND] is DEPRECATED and will be removed in a future version. Use kubectl exec [POD] -- [COMMAND] instead.
Defaulted container &quot;jks&quot; out of: jks, chauth (init)
bash-4.2$ cat /var/jenkins_home/secrets/initialAdminPassword
54c0b40b20f34b4ca7b75840c68883a1
然后填入管理员密码就ok
安装的插件如果不知道可以先选择推荐安装的插件
</code></pre>
<h2 id="任务">任务</h2>
<p>jenkins主要就是通过执行任务来工作的，左边菜单第一个按钮就是新建item</p>
<figure data-type="image" tabindex="4"><img src="https://koko-club.github.io/post-images/jenkins/image-20230215164410954.png" alt="image-20230215164410954" loading="lazy"></figure>
<p>主要使用的就是自由项目、流水线、多分支流水线，而从任务类型角度来讲主要就分为两种：流水线与非流水线</p>
<h3 id="非流水线自由风格">非流水线（自由风格）</h3>
<p>一般任务的步骤分为：推送代码-》触发钩子-》jenkins任务执行-》拉取代码-》构建操作-》构建后操作（一般是通知）</p>
<h4 id="拉取代码">拉取代码</h4>
<p>这里从拉取代码开始：</p>
<p>首先在创建freestyle project前需要先下载<a href="https://plugins.jenkins.io/git-parameter">Git Parameter</a>模块，在系统管理—》插件管理—》可选插件中搜索git parameter，下载并重启jenkins。</p>
<p>新建任务在源码管理中选择git，Repository URL输入git仓库地址，Credentials添加一个全局凭据用于git登录，指定分支中选择要拉取的分支。</p>
<h4 id="构建触发器">构建触发器</h4>
<p>构建触发器一般用于在代码仓库推送代码之后，触发触发器然后jenkins开始构建对应的任务。这个需要<a href="https://plugins.jenkins.io/generic-webhook-trigger">Generic Webhook Trigger</a>插件，安装完毕重启即可。</p>
<h5 id="webhook触发jenkins任务配置">webhook触发jenkins任务配置</h5>
<p>首先需要在jenkins任务中配置触发器</p>
<figure data-type="image" tabindex="5"><img src="https://koko-club.github.io/post-images/jenkins/image-20230216111031873.png" alt="image-20230216111031873" loading="lazy"></figure>
<p>例如这里的token设置的是test，则触发器url为：http://jenkins/generic-webhook-trigger/invok?token=test</p>
<p>一般代码仓库如gitlab都会在具体项目里面有webhook配置，如下</p>
<figure data-type="image" tabindex="6"><img src="https://koko-club.github.io/post-images/jenkins/image-20230216110814851.png" alt="image-20230216110814851" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://koko-club.github.io/post-images/jenkins/image-20230216110830102.png" alt="image-20230216110830102" loading="lazy"></figure>
<p>首先将刚刚设置拿到的触发器url填入这个URL中，然后设置触发的动作，一般push events即可，表示其收到push操作时，则会触发。到这里webhook触发器就配置完成了，当gitlab推送代码时，jenkins会立即执行对应项目的任务。</p>
<h4 id="构建环境">构建环境</h4>
<p>构建环境主要构建前的一些操作，例如构建前删除工作区文件、使用密码文件或文本、如果卡住则终止构建等。这个配置不是必要配置，一般不用对构建环境做配置。</p>
<figure data-type="image" tabindex="8"><img src="https://koko-club.github.io/post-images/jenkins/image-20230216112310634.png" alt="image-20230216112310634" loading="lazy"></figure>
<h4 id="构建">构建</h4>
<p>构建最常用的就是执行shell命名，拉取代码以后的编译-》打包推送docker镜像（如果不打包就是二进制部署）-》部署 操作都在这一步完成。</p>
<figure data-type="image" tabindex="9"><img src="https://koko-club.github.io/post-images/jenkins/image-20230216112840235.png" alt="image-20230216112840235" loading="lazy"></figure>
<p>​	<img src="https://koko-club.github.io/post-images/jenkins/image-20230216112904780.png" alt="image-20230216112904780" loading="lazy"></p>
<p>直接在里面执行shell命令或者执行脚本就行了。</p>
<h4 id="构建后操作">构建后操作</h4>
<p>构建后常用配置是构建通知，一般常用的是email通知，jenkins默认支持email通知</p>
<figure data-type="image" tabindex="10"><img src="https://koko-club.github.io/post-images/jenkins/image-20230216113950123.png" alt="image-20230216113950123" loading="lazy"></figure>
<p>但现在比较流行用webhook进行通知，jenkins默认不支持这种配置，需要额外下载插件。</p>
<h5 id="企业微信通知">企业微信通知</h5>
<p>1、在需要发送企业微信通知的群中“添加群机器人”，得到webhook地址</p>
<p>2、在Jenkins系统管理-插件管理-可选插件，搜索&quot;Qy Wechat Notification Plugin&quot;插件，下载并重启Jenkins</p>
<p>3、配置系统配置</p>
<p>​		输入webhook地址，点击保存</p>
<figure data-type="image" tabindex="11"><img src="https://koko-club.github.io/post-images/jenkins/image-20230216131115946.png" alt="image-20230216130625028" loading="lazy"></figure>
<p>填入webhook即可，其他几项非必填项。</p>
<h5 id="钉钉通知">钉钉通知</h5>
<p>1、打开钉钉，进入群设置-智能群助手-添加机器人-自定义机器人（填写机器人名称、安全设置、协议）得到webhook</p>
<p>2、在Jenkins系统管理-插件管理-可选插件，搜索“DingTalk”，下载并重启Jenkins</p>
<p>3、配置系统配置</p>
<p>进入系统管理-系统配置-钉钉， 输入webhook地址、id、名称，主要是webhook地址以及钉钉那边机器人是否配置了关键字和加密，如果有需要输入<br>
<img src="https://koko-club.github.io/post-images/jenkins/image-20230216132900385.png" alt="image-20230216132900385" loading="lazy"></p>
<p>然后在任务配置中最上面就可以找到钉钉机器人</p>
<figure data-type="image" tabindex="12"><img src="https://koko-club.github.io/post-images/jenkins/image-20230216133032694.png" alt="image-20230216133032694" loading="lazy"></figure>
<p>如果不填写内容则为插件默认的告警模式，如需自定义需要看插件文档。</p>
<h4 id="maven任务">maven任务</h4>
<p>如果是java项目，可以使用maven风格来创建任务。首先需要按<a href="https://plugins.jenkins.io/maven-plugin">Maven Integration plugin</a>插件，安装后重启在创建任务时就可以看到选项</p>
<figure data-type="image" tabindex="13"><img src="https://koko-club.github.io/post-images/jenkins/image-20230216133527267.png" alt="image-20230216133527267" loading="lazy"></figure>
<p>maven风格项目主要是多了一个build选项，可以直接在配置中指定pom.xml进行maven打包，不像自由风格一样所有操作都需要通过shell来执行。这里需要安装maven工具，如果没有则会提示找不到工具，需要在全局工具配置中安装或指定工具目录。</p>
<figure data-type="image" tabindex="14"><img src="https://koko-club.github.io/post-images/jenkins/image-20230216133703880.png" alt="image-20230216133703880" loading="lazy"></figure>
<h3 id="流水线pipeline">流水线（pipeline）</h3>
<p>流水线其实就是通过pipeline的方式来配置任务流程。</p>
<h4 id="pipeline语法">pipeline语法</h4>
<figure data-type="image" tabindex="15"><img src="https://koko-club.github.io/post-images/jenkins/image-20230217104233727.png" alt="image-20230217104233727" loading="lazy"></figure>
<h5 id="pipeline示例">pipeline示例</h5>
<h6 id="示例1">示例1</h6>
<pre><code>pipeline {
	agent any

	stages{
		stage('获取代码') {
			steps {
			
	      checkout([$class: 'GitSCM', branches: [[name: '*/master']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: '4dc04ffd-15bf-46e3-a942-2b58f37bc26b', url: 'git@gitlab.zhangxianwei.com:dev/java.git']]])
			
			}
		}
		
		stage('代码检测'){
			steps {
				echo &quot;sonarqube check....&quot;
			}
		}		
		stage('代码构建'){
			steps {
				echo &quot;maven build.....&quot;
			}
		}	
		stage('代码部署'){
			steps {
			    echo &quot;echo sh&quot;
			//	sh -x '/server/scripts/deploy_html_tag.sh'
			}
		}
	}
	
}
</code></pre>
<h6 id="java项目构建pipeline示例">java项目构建pipeline示例</h6>
<pre><code>pipeline {
    agent {
        label &quot;edge-node&quot; 
    } 
    options {
    buildDiscarder(logRotator(numToKeepStr: '3'))
    disableConcurrentBuilds()
    }
    stages {

        stage('Check'){
            steps {
                sh &quot;mvn sonar:sonar&quot;
            }
        }
        stage('Clean') {
            steps {
               sh &quot;mvn clean&quot;
            }
        }
        stage('Build') {
            steps {
                sh &quot;mvn compile&quot;
            }
        }
        stage('Package') {
            steps {
                sh &quot;mvn package -Dmaven.test.skip=true -P&quot;+env.BRANCH_NAME
            }
        }
        stage('Deploy') {
            steps {
                sh &quot;mvn deploy -Dmaven.test.skip=true -P&quot;+env.BRANCH_NAME
            }
        }

        stage('IN') {
            steps {
                 sh &quot;~/kubectl_update.sh ${env.WORKSPACE} ${env.JOB_NAME}&quot;
            }
        }
    }
     post {
        success {
            dingTalk(
                robot: 'jenkins', 
                type:'MARKDOWN', 
                title: &quot;构建成功: ${JOB_NAME}&quot;, 
                text: [&quot;## [${JOB_NAME}](${JOB_URL})&quot;,
                       &quot;---&quot;,
                       &quot;- 任务: [${BUILD_DISPLAY_NAME}](${BUILD_URL})&quot;,
                       &quot;- 状态: &lt;font color=green&gt;成功&lt;/font&gt;&quot;,
                       &quot;- 持续时间: ${currentBuild.durationString}&quot;,	],	
            )
        }
        failure {
            dingTalk(
                robot: 'jenkins', 
                type:'MARKDOWN', 
                title: &quot;构建失败: ${JOB_NAME}&quot;, 
                text: [&quot;## [${JOB_NAME}](${JOB_URL})&quot;,
                       &quot;---&quot;,
                       &quot;- 任务: [${BUILD_DISPLAY_NAME}](${BUILD_URL})&quot;,
                       &quot;- 状态: &lt;font color=red&gt;失败&lt;/font&gt;&quot;,
                       &quot;- 持续时间: ${currentBuild.durationString}&quot;,	],		
            ) 
        }
    }
}
</code></pre>
<h6 id="前端项目构建pipeline示例">前端项目构建pipeline示例</h6>
<pre><code>pipeline {
    agent {
        label &quot;edge-node&quot;
    }

    stages {

        stage('Check'){
            steps {
                sh &quot;~/sonar-scanner-4.7.0.2747-linux/bin/sonar-scanner -Dsonar.login=admin -Dsonar.password=finsi0t.c0m&quot; 
            }
        }
        stage('Clean') {
            steps {
               sh &quot;npm cache clean --force&quot;
            }
        }
        stage('Build') {
            steps {
                sh &quot;npm install &amp;&amp; npm run build:pro&quot;
            }
        }
        stage('Install') {
            steps {
               sh &quot;~/kubectl_update.sh ${env.WORKSPACE} ${env.JOB_NAME}&quot;
            } 
        }


    }
    options {
        buildDiscarder(logRotator(numToKeepStr: '3'))
        disableConcurrentBuilds()
    }
     post {
        success {
            dingTalk(
                robot: 'jenkins', 
                type:'MARKDOWN', 
                title: &quot;构建成功: ${JOB_NAME}&quot;, 
                text: [&quot;## [${JOB_NAME}](${JOB_URL})&quot;,
                       &quot;---&quot;,
                       &quot;- 任务: [${BUILD_DISPLAY_NAME}](${BUILD_URL})&quot;,
                       &quot;- 状态: &lt;font color=green&gt;成功&lt;/font&gt;&quot;,
                       &quot;- 持续时间: ${currentBuild.durationString}&quot;,	],	
            )
        }
        failure {
            dingTalk(
                robot: 'jenkins', 
                type:'MARKDOWN', 
                title: &quot;构建失败: ${JOB_NAME}&quot;, 
                text: [&quot;## [${JOB_NAME}](${JOB_URL})&quot;,
                       &quot;---&quot;,
                       &quot;- 任务: [${BUILD_DISPLAY_NAME}](${BUILD_URL})&quot;,
                       &quot;- 状态: &lt;font color=red&gt;失败&lt;/font&gt;&quot;,
                       &quot;- 持续时间: ${currentBuild.durationString}&quot;,	],		
            ) 
        }
    }
}
</code></pre>
<h4 id="创建流水线项目">创建流水线项目</h4>
<figure data-type="image" tabindex="16"><img src="https://koko-club.github.io/post-images/jenkins/image-20230216152357088.png" alt="image-20230216152357088" loading="lazy"></figure>
<figure data-type="image" tabindex="17"><img src="https://koko-club.github.io/post-images/jenkins/image-20230216152342895.png" alt="image-20230216152342895" loading="lazy"></figure>
<figure data-type="image" tabindex="18"><img src="https://koko-club.github.io/post-images/jenkins/image-20230216153134214.png" alt="image-20230216153134214" loading="lazy"></figure>
<p>这里pipeline有两种方式，一种是直接在jenkins上面写，还有一种是来自仓库的pipeline文件，如上图。默认脚本文件路径是代码项目根目录下的Jenkinsfile。</p>
<p>下面是我这里gitlab存放的用于测试的jenkinsfile：</p>
<figure data-type="image" tabindex="19"><img src="https://koko-club.github.io/post-images/jenkins/image-20230216164244800.png" alt="image-20230216164244800" loading="lazy"></figure>
<p>jenkinsfile(pipeline)和jenkins流水线配置完成之后就可以执行任务了。需要注意的是这里的git拉取仓库只能写在pipeline中，不能像自由风格和maven风格任务一样在任务配置中设置源码管理（git）。这里钩子触发的配置和上面一样，但构建后通知是写在pipeline中的，下面的多分支流水线会写。</p>
<h5 id="jenkins中的流水线语法生成器">jenkins中的流水线语法生成器</h5>
<p>如果不熟悉流水线语法可以在配置任务中选择流水线语法，跳转到语法生成器。</p>
<figure data-type="image" tabindex="20"><img src="https://koko-club.github.io/post-images/jenkins/image-20230217104911232.png" alt="image-20230217104911232" loading="lazy"></figure>
<figure data-type="image" tabindex="21"><img src="https://koko-club.github.io/post-images/jenkins/image-20230217104951115.png" alt="image-20230217104951115" loading="lazy"></figure>
<p>例如我这里生成一个git拉取代码的pipeline片段</p>
<figure data-type="image" tabindex="22"><img src="https://koko-club.github.io/post-images/jenkins/image-20230217105413932.png" alt="image-20230217105413932" loading="lazy"></figure>
<h4 id="多分支流水线">多分支流水线</h4>
<p>多分支流水线和流水线不同的地方是多分支流水线可以直接对一个项目多个分支进行任务。在实际中，需要多分支同时进行开发。如果每个分支都创建一个Jenkins项目，比较多余。一般企业生产中也会采用这种方式。</p>
<figure data-type="image" tabindex="23"><img src="https://koko-club.github.io/post-images/jenkins/63e1c8cfbe940700149b78e776a5f7e0.png" alt="img" loading="lazy"></figure>
<p>新建任务中选择多分支流水线</p>
<figure data-type="image" tabindex="24"><img src="https://koko-club.github.io/post-images/jenkins/image-1607389282641.png" alt="file" loading="lazy"></figure>
<h5 id="分支源配置">分支源配置</h5>
<p>填入git项目地址以及登录凭据，添加行为clean before/after checkout 用于清理未跟踪的文件</p>
<figure data-type="image" tabindex="25"><img src="https://koko-club.github.io/post-images/jenkins/image-20230217101740905.png" alt="image-20230217101740905" loading="lazy"></figure>
<h5 id="build-configuration">build configuration</h5>
<p>如果是仓库根目录下的jenkinsfile就用默认即可，需要注意的是项目下需要执行jenkins任务的分支都需要有jenkinsfile，每个分支的jenkinsfile是独立的。</p>
<figure data-type="image" tabindex="26"><img src="https://koko-club.github.io/post-images/jenkins/image-20230217101839957.png" alt="image-20230217101839957" loading="lazy"></figure>
<h5 id="扫描-多分支流水线-触发器">扫描 多分支流水线 触发器</h5>
<p>多分支流水线钩子触发器需要下载插件：Multibranch Scan Webhook Trigger。</p>
<p>安装完以后在扫描 多分支流水线 触发器中选择scan by webhook，输入trigger token。例如这里输入的是test，则gitlab那边设置触发钩子配置的url就应该是</p>
<p>http(s)😕/JENKINS_URL/multibranch-webhook-trigger/invoke?token=test</p>
<figure data-type="image" tabindex="27"><img src="https://koko-club.github.io/post-images/jenkins/image-20230217103028959.png" alt="image-20230217103028959" loading="lazy"></figure>
<p>配置完保存以后会自动开始扫描多分支</p>
<figure data-type="image" tabindex="28"><img src="https://koko-club.github.io/post-images/jenkins/image-20230217103434365.png" alt="image-20230217103434365" loading="lazy"></figure>
<p>由于我这里有两个分支mian、master配置了jenkinsfile，则这两个分支可以构建任务</p>
<figure data-type="image" tabindex="29"><img src="https://koko-club.github.io/post-images/jenkins/image-20230217103520226.png" alt="image-20230217103520226" loading="lazy"></figure>
<figure data-type="image" tabindex="30"><img src="https://koko-club.github.io/post-images/jenkins/image-20230217103531928.png" alt="image-20230217103531928" loading="lazy"></figure>
<p>多分支和钩子触发器都配置完毕后，在git仓库那边对对应分支进行push操作，这边就会自动开始构建任务</p>
<h2 id="安全">安全</h2>
<p>安全配置位于：系统配置-》安全全局配置</p>
<h3 id="凭据">凭据</h3>
<p>这个上面在git拉取时已经用到过了，就不详细讲述了。就是存放密钥或者账号密码的模块，在系统管理-》凭据管理中可以配置（配置任务时也可以直接添加凭据）。</p>
<h3 id="安全域">安全域</h3>
<p>安全域主要是定义jenkins用户的数据源，默认是 Jenkins自带的用户数据库。</p>
<p>配置路径：jenkins设置-》全局安全配置-安全域</p>
<p>这个一般使用默认项就行，如果有ldap配置需求也可以选择ldap（用户数据使用ldap的数据库）。</p>
<h3 id="授权策略">授权策略</h3>
<h4 id="登录用户可以做任何事">登录用户可以做任何事</h4>
<p>授权策略默认是“登录用户可以做任何事“，表示登录用户皆为最高权限，其中有一个子选项是”匿名用户具有可读权限“，一般会配合子选项进行使用。（登录的是管理员，不登陆就只有只读权限）</p>
<h4 id="任何用户可以做任何事没有任何限制">任何用户可以做任何事(没有任何限制)</h4>
<p>简明知意，所有用户（包括匿名用户）都有最高权限。一般不用</p>
<h4 id="安全矩阵和项目矩阵授权策略">安全矩阵和项目矩阵授权策略</h4>
<p>根据用户或用户组授予对应权限，可以精确到具体模块权限，但一般不会使用，因为有一个更好的模块Role-Based Strategy作为替代。</p>
<h4 id="role-based-strategy">Role-Based Strategy</h4>
<p>角色授权模块，也是最常用的策略，需要先下载模块<a href="https://plugins.jenkins.io/role-strategy">Role-based Authorization Strategy</a>。</p>
<p>应用Role-Based Strategy以后，选择 系统管理-》安全-》Manage and Assign Roles</p>
<h5 id="管理角色">管理角色</h5>
<p>位于系统管理-》安全-》Manage and Assign Roles-》管理角色</p>
<p>管理角色主要的功能就是创建一个角色，并对于角色授予权限，然后将角色赋予用户或用户组</p>
<h6 id="global-roles">Global roles</h6>
<p>全局管理，可以对用户或组授予权限（输入用户 add以后通过选择打勾授予对应模块权限，然后保存生效）。<img src="https://koko-club.github.io/post-images/jenkins/image-20230220153651762.png" alt="image-20230220153651762" loading="lazy"></p>
<figure data-type="image" tabindex="31"><img src="https://koko-club.github.io/post-images/jenkins/image-20230220153700562.png" alt="image-20230220153700562" loading="lazy"></figure>
<h6 id="item-roles">Item roles</h6>
<p>通过项目进行授权，可以使用正则匹配。例如我这里是授予有英文字母a-z的项目权限</p>
<figure data-type="image" tabindex="32"><img src="post-images/jenkins/image-20230220160917798.png" alt="image-20230220160917798" loading="lazy"></figure>
<h6 id="node-roles">Node roles</h6>
<p>Node roles在Jenkins集群环境下使用，配置不同结点的Jenkins权限。（目前没使用过，如后期有使用会补上这一块内容）</p>
<h5 id="分配角色">分配角色</h5>
<p>分配角色也是三大块：Global roles、Item roles、Node roles。分配主要就是添加用户、用户组然后勾选上面创建好的角色，此时用户、用户组则拥有了该角色的权限。</p>
<p>备注：jenkins默认没有组选项，只能通过active directory或者ldap对接jenkins用户数据来使用用户组管理。</p>
<h2 id=""></h2>
<h2 id="其他问题">其他问题</h2>
<h3 id="k8s环境中可能出现的问题">k8s环境中可能出现的问题</h3>
<h4 id="时区">时区</h4>
<p>时区默认肯定不是国内的，最简便的解决方法是通过挂载主机（k8s hostpath方法）的时区文件(/etc/localtime)解决。或者dockerfile用jenkins作为基础镜像，再加上时区修改的配置也可以。</p>
<h4 id="中文乱码">中文乱码</h4>
<p>这个是不是k8s都有可能出现这个问题，主要是主机的字符集格式需要修改为中文utf-8。如果是k8s的话需要dockerfile重新打一下镜像，改成中文utf-8，或者每次启动时安装utf-8中文并配置（一般jenkins镜像没有中文utf-8）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ldap]]></title>
        <id>https://koko-club.github.io/post/ldap/</id>
        <link href="https://koko-club.github.io/post/ldap/">
        </link>
        <updated>2023-02-12T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="ldap">ldap</h1>
<h2 id="什么是ldap">什么是ldap</h2>
<pre><code>        首先LDAP是一种通讯协议，LDAP支持TCP/IP。协议就是标准，并且是抽象的。在这套标准下，AD（Active Directory）是微软出的一套实现。
        那AD是什么呢？暂且把它理解成是个数据库。也有很多人直接把LDAP说成数据库(可以把LDAP理解成存储数据的数据库)。像是其他数据库一样，LDAP也是有client端和server端。server端是用来存放资源，client端用来操作增删改查等操作。
        而我们通常说的LDAP是指运行这个数据库的服务器。
        可以简单理解AD =LDAP服务器＋LDAP应用。
</code></pre>
<h2 id="用途">用途</h2>
<pre><code>用于统一认证管理，统一公司内部服务账号密码。
</code></pre>
<h2 id="ldap-模型">LDAP 模型</h2>
<h3 id="基本模型">基本模型</h3>
<pre><code>目录树：在一个目录服务系统中，整个目录信息集可以表示为一个目录信息树，树中的每个节点是一个条目。
条目：每个条目就是一条记录，每个条目有自己的唯一可区别的名称（DN）。
对象类：是某个实体类型对应的一组属性，对象类可以继承，父类的必须属性也会被继承下来。
属性：描述条目的某个方面的信息，一个属性由一个属性类型和一个或多个属性值组成，属性有必须属性和非必须属性。

</code></pre>
<table>
<thead>
<tr>
<th><strong>关键字</strong></th>
<th><strong>英文全称</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>dc</strong></td>
<td>Domain Component</td>
<td>域名的部分，其格式是将完整的域名分成几部分，如域名为example.com变成dc=example,dc=com（一条记录的所属位置）</td>
</tr>
<tr>
<td><strong>uid</strong></td>
<td>User Id</td>
<td>用户ID songtao.xu（一条记录的ID）</td>
</tr>
<tr>
<td><strong>ou</strong></td>
<td>Organization Unit</td>
<td>组织单位，组织单位可以包含其他各种对象（包括其他组织单元），如“oa组”（一条记录的所属组织）</td>
</tr>
<tr>
<td><strong>cn</strong></td>
<td>Common Name</td>
<td>公共名称，如“Thomas Johansson”（一条记录的名称）</td>
</tr>
<tr>
<td><strong>sn</strong></td>
<td>Surname</td>
<td>姓，如“许”</td>
</tr>
<tr>
<td><strong>dn</strong></td>
<td>Distinguished Name</td>
<td>“uid=songtao.xu,ou=oa组,dc=example,dc=com”，一条记录的位置（唯一）</td>
</tr>
<tr>
<td><strong>rdn</strong></td>
<td>Relative dn</td>
<td>相对辨别名，类似于文件系统中的相对路径，它是与目录树结构无关的部分，如“uid=tom”或“cn= Thomas Johansson”</td>
</tr>
</tbody>
</table>
<pre><code>dn ：一条记录的详细位置。目录位置
dc ：一条记录所属区域 (哪一颗树)。根名称
ou ：一条记录所属组织 （哪一个分支）。组名称
cn/uid：一条记录的名字/ID (哪一个苹果名字)。用户名称
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://koko-club.github.io/post-images/ldap/ldap_tree.png" alt="img" loading="lazy"></figure>
<h3 id="信息模型">信息模型</h3>
<p>LDAP中，信息以树状方式进行组织的，在树状信息中的基本数据单元是条目，而每个条目由属性构成，属性中存储有属性值;</p>
<h3 id="命名模型">命名模型</h3>
<p>即LDAP中的条目定位方式，在LDAP中每个条目均有自己的DN。<br>
DN是该条目在整个树中的唯一名称标识，</p>
<p>如同文件系统中，带路径的文件名就是DN。</p>
<h3 id="功能模型">功能模型</h3>
<p>在LDAP中共有四类10种操作︰<br>
查询类操作：如搜索、比较;<br>
更新类操作：如添加条目、删除条目、修改条目、修改条目名;<br>
认证类操作：如绑定、解绑定;<br>
其它操作：如放弃和扩展操作。</p>
<p>除了扩展操作，另外9种是LDAP的标准操作﹔</p>
<p>扩展操作是LDAP中为了增加新的功能，提供的一种标准的扩展框架，当前已经成为LDAP标准的扩展操作，有修改密码和startTLS扩展，</p>
<p>在新的RFC标准和草案中正在增加一些新的扩展操作，不同的LDAP厂商也均定义了自己的扩展操作。</p>
<h3 id="安全模型">安全模型</h3>
<p>安全模型主要通过身份认证、安全通道和访问控制来实现。</p>
<h1 id="ldap-server">ldap server</h1>
<p>一般ldap服务端比较常用的是openldap，这里仅记录openldap的部署及使用。</p>
<h2 id="openldap">openldap</h2>
<h3 id="k8s部署">k8s部署</h3>
<p>直接用yaml部署就行，镜像用的是bitnami的ldap镜像</p>
<pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: openldap
spec:
  replicas: 1
  selector:
    matchLabels:
      app: openldap
  strategy:
    rollingUpdate:
      maxSurge: 25%
      maxUnavailable: 25%
    type: RollingUpdate
  template:
    metadata:
      labels:
        app: openldap
    spec:
      containers:
      - env:
        - name: LDAP_ADMIN_USERNAME
          value: admin
        - name: LDAP_ADMIN_PASSWORD
          value: &quot;123456&quot;
        - name: LDAP_USERS
          value: manager
        - name: LDAP_PASSWORDS
          value: &quot;123456&quot;
        - name: LDAP_ROOT
          value: dc=finsiot,dc=com
        image: bitnami/openldap:latest
        imagePullPolicy: Always
        name: openldap
        ports:
        - containerPort: 1389
          name: service
          protocol: TCP
        resources:
          limits:
            cpu: &quot;1&quot;
            memory: 2Gi
          requests:
            cpu: &quot;1&quot;
            memory: 2Gi
        volumeMounts:
        - mountPath: /bitnami/openldap/data
          name: openldap-pvc
          subPath: ldap
        - mountPath: /bitnami/openldap/slapd.d
          name: openldap-pvc
          subPath: slapd.d
      dnsPolicy: ClusterFirst
      restartPolicy: Always
      schedulerName: default-scheduler
      securityContext: {}
      terminationGracePeriodSeconds: 30
      volumes:
      - name: openldap-pvc
        persistentVolumeClaim:
          claimName: ldap-pvc
---

apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: ldap-pvc
  labels:
    app: ldap
spec:
  storageClassName: csi-rbd-sc   #这里的storageclass是我们之前申请的
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 2Gi
---
apiVersion: v1
kind: Service
metadata:
  name: openldap
spec:
  #clusterIP: 192.168.110.29
  #externalTrafficPolicy: Cluster
  ports:
  - nodePort: 30300
    port: 1389
    protocol: TCP
    targetPort: service
  selector:
    app: openldap
  sessionAffinity: None
  type: NodePort
status:
  loadBalancer: {}
</code></pre>
<h3 id="ldap二进制部署">ldap二进制部署</h3>
<p>这里没有尝试过二进制部署ldap，后面会写。</p>
<h3 id="ldap管理">ldap管理</h3>
<p>管理操作ldap数据可以使用ldap客户端或者ldap管理服务工具实现。如果使用ldap windows客户端可以下载LDAPSoft Ldap Browser使用，如果使用管理web页面可以部署服务：ldapphpadmin。</p>
<h2 id="ldapphpadmin">ldapphpadmin</h2>
<h3 id="k8s部署-2">k8s部署</h3>
<pre><code>
apiVersion: apps/v1
kind: Deployment
metadata:
  annotations:
    kompose.cmd: kompose convert -f docker-compose.yml
    kompose.version: 1.16.0 (0c01309)
  creationTimestamp: null
  labels:
    io.kompose.service: phpldapadmin
  name: phpldapadmin
spec:
  replicas: 1
  strategy: {}
  selector:                #定义选择器
    matchLabels:           #匹配上面的标签
        io.kompose.service: phpldapadmin         #匹配模板名称
  template:
    metadata:
      creationTimestamp: null
      labels:
        io.kompose.service: phpldapadmin
    spec:
      containers:
      - env:
        - name: PHPLDAPADMIN_HTTPS
          value: &quot;false&quot;
        - name: PHPLDAPADMIN_LDAP_HOSTS
          value: 'ldap://192.168.110.29:30389'
        image: osixia/phpldapadmin:0.7.1
        name: phpldapadmin
        ports:
        - containerPort: 80
        resources: {}
      restartPolicy: Always
---
apiVersion: v1
kind: Service
metadata:ZZ
  labels:
    io.kompose.service: phpldapadmin
  name: phpldapadmin
spec:
  ports:
  - name: &quot;8080&quot;
    port: 8080
    targetPort: 80
  selector:
    io.kompose.service: phpldapadmin
</code></pre>
<h1 id="ldap-for-nexus">ldap for nexus</h1>
<p>本文主要为nexus集成到ldap的配置，由于网上关于该功能的配置大都层次不齐且写的太模糊，故记录此文档。</p>
<h2 id="1-ldap配置">1、ldap配置</h2>
<p>这里ldap用的是openldap，所以首先需要部署好openldap。首先想要在nexus中集成ldap，ldap的服务端必须要有组和用户。</p>
<pre><code>这里的组用来映射与nexus的角色，使其组下面的用户都拥有nexus映射角色的权限，无需额外配置。
这里的用户则用来登录nexus。
</code></pre>
<p>所以需要创建好组和用户，这里以映射一个nexus管理员为例子，首先创建准备好ldap的用户和组：</p>
<pre><code>创建一个ou为nexus，组为manager，用户为nexus，先创建组，然后创建用户指定组。
组:cn=manager,ou=nexus,dc=finsiot,dc=com
用户:cn=nexus,ou=nexus,dc=finsiot,dc=com
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://koko-club.github.io/post-images/ldap/image-20221110171353237.png" alt="image-20221110171353237" loading="lazy"></figure>
<h2 id="2-nexus配置">2、nexus配置</h2>
<pre><code>	1.访问nexus-web管理页面，登录管理员账号，进入设置-》secruity-》LDAP-》create connection
	2.connection配置：
		name：这个是要创建的ldap名称，可以随便填，非关键性参数。
		Ldap server address:填入ldap地址
		Search base Dn:填入dn地址（dc的地址）
		Authentication method: Simple Authentication
		Username or DN: 填入登录用户名(一般用admin管理员登录)
		password: 密码
	3.User and group配置：
		configuration template: 选择一个模板，非关键性参数，只是会预先给出下面一些参数的值。这里可以选posix with static groups
		user relative dn(base dn):对应于用作用户条目基础的专有名称集合。此DN与前面的search base相关。例如，如果用户都包含在ou = nexus，dc=finsiot,dc=com中，前面登录时指定了dc=finsiot,dc=com的搜索库，则这里使用值ou = nexus。
		User subtree： 如果基本DN下面的树可以包含用户条目，则值为true;如果所有用户都包含在指定的基本DN中，则为false。例如，如果所有用户都在ou = users，dc = sonatype，dc = com，则此字段应为False。如果用户可以在组织单位内的组织单位中显示，例如ou = development，ou = users，dc = sonatype，dc = com，则此字段应为True。
		Object class： 此值是RFC-2798中定义的标准对象类。它为用户指定对象类。常见值为inetOrgPerson，person，user或posixAccount。这里使用模板默认的posixAccount
		User filter： 这允许您配置过滤器以限制对用户记录的搜索。它可以用作性能改进。这里不用填写。
		User ID attribute： 这是上面指定的对象类的属性，它从LDAP服务器提供用户的标识符。存储库管理器使用此属性作为用户ID值。在ldap创建了用户以后，里面有一个属性值（默认为uid），例如我这里创建了一个nexus的用户，则会有一个uid的值为nexus，nexus服务需要通过这个key:value来找到该用户
		Real name attribute： 这是Object类的属性，它提供用户的真实姓名。存储库管理器在需要显示用户的真实姓名时使用此属性，类似于内部名字和姓氏属性的使用。这个也是去找ldap里面的kv属性，默认是key的名称为cn。
		Email attribute: 同上面的User ID attribute和Real name attribute，默认key的名称为mail。
		Password attribute:不用填写，这里为空则会在登录时读取ldap中用户的password字段。
		Map LDAP groups as roles：这里需要勾选，下面是组的配置，用于将ldap组映射于nexus。
		Group type: static Groups 这里选择静态组
		Group relative DN: 指名组的DN位置，例如我这里manager组在nexus下面，则这里填ou=nexus。
		Group subtree: 勾选，表示是位于group下面的子组。例如我上面ou=nexus，则这里勾选的意思是nexus下面的组。
		Group object class: 组创建时会有这个字段，默认为posixGroup。和上面定义User ID attribute和Real name attribute和Email attribute是一样的。
		Group ID attribute： 这里表示组的id属性，和上面定义User ID attribute和Real name attribute和Email attribute是一样的。
		Group member attribute: 这里表示组里面有哪些成员，和上面两个属性一样，也是ldap组中的字段，但默认不会创建这个字段，请手动创建memberUid的字段并把成员的字段值写入该字段，否则会找不到映射的角色。
		Group member format: 该字段用来找到memberUid中的组员名称的，使用变量${username}。
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://koko-club.github.io/post-images/ldap/image-20221110171338946.png" alt="image-20221110171338946" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://koko-club.github.io/post-images/ldap/image-20221110171215302.png" alt="image-20221110171215302" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://koko-club.github.io/post-images/ldap/image-20221110171237900.png" alt="image-20221110171237900" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://koko-club.github.io/post-images/ldap/image-20221110171249864.png" alt="image-20221110171249864" loading="lazy"></figure>
<h3 id="创建角色">创建角色</h3>
<p>在nexus设置-》security-》roles中添加一个role，type为external role mapping，external role type为ldap。</p>
<figure data-type="image" tabindex="7"><img src="https://koko-club.github.io/post-images/ldap/image-20221110171612944.png" alt="image-20221110171612944" loading="lazy"></figure>
<pre><code>Mapped Role：请填写为ldap中创建的组名称，两个服务会通过名称进行映射，例如我这里ldap中有一个nexus用户，在manager组下面，于是这里我定义一个mapped role为manager，则nexus以及ldap中manager组中所有用户都会拥有这里定义好的权限，也就是组权限映射。
Role Name： role角色的名称。
Role Description： 角色介绍。
Privileges：定义的是角色的权限。
Roles：可以与其它定义好的role关联权限。
</code></pre>
<h3 id="测试">测试</h3>
<p>创建好以后回到刚刚的ldap设置，点击刚刚创建的ldap，进入user and group设置，最下方有一个 verify user mapping 。</p>
<figure data-type="image" tabindex="8"><img src="https://koko-club.github.io/post-images/ldap/image-20221110171936912.png" alt="image-20221110171936912" loading="lazy"></figure>
<p>点击属于ldap密码就可以看到目前定义映射的组和用户情况</p>
<figure data-type="image" tabindex="9"><img src="https://koko-club.github.io/post-images/ldap/image-20221110172056058.png" alt="image-20221110172056058" loading="lazy"></figure>
<p>这里user id其实就是上面user id attribute配置，name为Real name attribute配置，email为Email attribute，roles是Map LDAP groups as roles及下面所有组配置定义的。如果有没有数据的字段，请检查该项对应配置的字段是否正常配置，例如如果roles没有，请看一下Map LDAP groups as roles下面的配置是否正确。</p>
<h1 id="ldap-for-jenkins">ldap for jenkins</h1>
<p>jenkins集成ldap的方法</p>
<h2 id="1-安装插件">1、安装插件</h2>
<figure data-type="image" tabindex="10"><img src="https://koko-club.github.io/post-images/ldap/cb436a8c487d4df0b47bfea2f494bf77.png" alt="Jenkins安装LDAP插件" loading="lazy"></figure>
<h2 id="2-配置ldap">2、配置ldap</h2>
<p>进入管理设置（manage jenkins）-&gt;全局安全设置(configure global security),设置安全域为ldap</p>
<figure data-type="image" tabindex="11"><img src="https://koko-club.github.io/post-images/ldap/image-20230210101753775.png" alt="image-20230210101753775" loading="lazy"></figure>
<h3 id="配置项">配置项</h3>
<pre><code>Server：ldap的地址url
root DN：根DN目录路径
User search base：查找用户的目录
User search filter：查找用户的条件
Group search base： 查找用户组的目录
Group search filter： 用户组条件(查找用户的条件)
Group membership：选择 Search for LDAP groups containing user
Manager DN： 管理员所在路径
Manager Password： 管理员密码
Display Name LDAP attribute： jenkins对应ldap用户名的字段
Email Address LDAP attribute：email字段
</code></pre>
<p>配置示例：</p>
<figure data-type="image" tabindex="12"><img src="https://koko-club.github.io/post-images/ldap/image-20230210102814010.png" alt="image-20230210102814010" loading="lazy"></figure>
<p>这里ldap的结构为，用户目录：ou=people,dc=xxx,dc=com，用户组目录：ou=group,dc=xxx,dc=com</p>
<figure data-type="image" tabindex="13"><img src="https://koko-club.github.io/post-images/ldap/image-20230210103422255.png" alt="image-20230210103422255" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://koko-club.github.io/post-images/ldap/image-20230210103437606.png" alt="image-20230210103437606" loading="lazy"></figure>
<p>这里需要注意的点是：user search filter用于找到用户，如果这里填错了将会找不到用户。group search base则是用于找到用户组，如果这里填错了将找不到用户，而search filter用于找到用户组中的用户(&amp;(objectClass=posixGroup)(memberUid={1}))，这里的用户组主要用于授权时使用，对组进行授权。</p>
<h2 id="测试-2">测试</h2>
<p>配置完成可以点击test ldap settings测试一下：</p>
<figure data-type="image" tabindex="15"><img src="https://koko-club.github.io/post-images/ldap/image-20230210104457142.png" alt="image-20230210104457142" loading="lazy"></figure>
<figure data-type="image" tabindex="16"><img src="https://koko-club.github.io/post-images/ldap/image-20230210104515248.png" alt="image-20230210104515248" loading="lazy"></figure>
<h1 id="ldap-for-gitlab">ldap for gitlab</h1>
<p>gitlab并不能直接通知页面设置来对接ldap，而是通过配置文件。</p>
<h2 id="1-ldap配置二进制部署">1、ldap配置（二进制部署）</h2>
<p>这里配置分为两种：一种是二进制包部署的gitlab，这个由于我并没有部署过，所以下面的配置摘抄于网上，不清楚版本有没有配置变化，但配置大致的字段基本应该是一致的；还有一种方法是k8s的配置，这种也是目前我在使用的方式，会在下面列出来。</p>
<pre><code>如果是二进制部署的则直接更改配置文件
vi /etc/gitlab/gitlab.rb

gitlab_rails['ldap_enabled'] = true
gitlab_rails['prevent_ldap_sign_in'] = false
gitlab_rails['ldap_servers'] = {
'main' =&gt; {
  'label' =&gt; 'LDAP', # 随便自定义
  'host' =&gt;  '10.0.20.19', # ldap的server地址
  'port' =&gt; 389, # ldap端口
  'uid' =&gt; 'cn', # 配置为cn或者sn都可以，但要注意用户名称将会以此处配置为依据
  'bind_dn' =&gt; 'cn=admin,dc=aihelp,dc=net', # 管理员账号
  'password' =&gt; '123456', # 管理员密码
  'encryption' =&gt; 'plain',  # 加密
  'allow_username_or_email_login' =&gt; false,  # 是否启用邮件作为用户名登陆
  'block_auto_created_users' =&gt; false, 
  'base' =&gt; 'dc=aihelp,dc=net',   # 核心配置，表示从哪一层读取用户信息
  'user_filter' =&gt; '(memberof=cn=jenkins,ou=group,dc=aihelp,dc=net)', # LDAP用户进行过滤
  'lowercase_usernames' =&gt; false,
  'group_base' =&gt; '',
  'admin_group' =&gt; '',
  'external_groups' =&gt; [],
  'sync_ssh_keys' =&gt; false
  }
}


</code></pre>
<pre><code>其中：
label 是显示在GitLab登录框的上方文字描述。
host 和 port 是 LDAP 服务的主机地址及端口
bind_dn 和 password 是一个管理 LDAP 的 dn 及密码
base 表示 LDAP 将以该 dn 为 节点，向下查找用户
user_filter 表示以某种过滤条件筛选用户，比如假设我们只希望所属组为 java-platform 的用户来访问 GitLab，则可以在这里设置 (memberOf=ou=java-platform,ou=people,dc=domain,dc=com)

配置添加之后，依旧像安装时候那样，重载一下配置：
gitlab-ctl reconfigure

 
Checking LDAP ...
LDAP: ... Server: ldapmain
LDAP authentication... Success
LDAP users with access to your GitLab server (only showing the first 100 results)
    DN: uid=test01,ou=people,dc=eryajf,dc=net    cn: ceshi
    DN: uid=test02,ou=people,dc=eryajf,dc=net    cn: test02
    DN: uid=test03,ou=people,dc=eryajf,dc=net    cn: test03
    DN: uid=admin,ou=people,dc=eryajf,dc=net     cn: Admin
Checking LDAP ... Finished
使用ldap用户名密码进行登陆即可，此时登陆进去是没有任何项目的权限，如果需要某权限，可以对用户进行组或者单项目的授权。
</code></pre>
<h2 id="2-ldap配置k8s">2、ldap配置(k8s)</h2>
<p>ldap这里直接用helm的values.yaml传递配置文件信息，所以在ldap中配置就行了。这里如果是部署也建议采用helm部署，由于gitlab新版本模块过多，如果写yaml文件的话再加上配置文件和需要持久化的存储路径很麻烦，所以使用helm是比较理想的方式。</p>
<pre><code>values.yaml:
----
    ldap:
      # prevent the use of LDAP for sign-in via web.
      preventSignin: false
      servers:
        main:
          label: 'LDAP' 
          host: '192.168.110.29' #ldap地址
          port: 30389 #端口
          uid: 'uid' 
          bind_dn: 'cn=admin,dc=finsiot,dc=com' #管理员路径
          password: #管理员密码
            secret: my-ldap-password-secret
            key: the-key-containing-the-password
          encryption: 'plain'
          base: 'ou=people,dc=finsiot,dc=com' #用户路径
          verify_certificates: true #忽略证书
          active_directory: false
          allow_username_or_email_login: true #支持邮件和用户名登录
          block_auto_created_users: false
          user_filter: ''
          attributes:
            username: ['cn'] #用户名对应ldap字段
            email:    ['mail','email'] #邮箱对应ldap字段
            name:     'description' #用户显示名字对应ldap字段
            fister_name: 'givenName' 
            last_name:  'sn'
</code></pre>
<p>需要注意的是，gitlab-ce仅支持ldap的用户配置，不支持ldap用户组的配置，如果想要使用ldap用户组，需要使用gitlab-ee（商业版本）。</p>
<p>ldap的配置文件是configmap：gitlab-webservice下面的gitlab.yml.erb，挂载于gitlab-webservice-default的/var/opt/gitlab/templates/gitlab.yml.erb路径。</p>
<h3 id="gitlab拉取ldap账号数据">gitlab拉取ldap账号数据</h3>
<h4 id="问题">问题</h4>
<p>ldap与应用结合一般有两种，一种是服务需要登录时去调用ldap的账号数据实现结合，还有一种是服务预先将ldap存在自己数据库中然后通过ldap的账号进行登录。而gitlab则是后者，这种情况会导致新加了账号但是ldap却没办法直接用新账号登录，因为gitlab并非是登录直接去ldap调用，而是从自己数据库中找ldap账号数据。</p>
<h4 id="解决办法">解决办法</h4>
<h5 id="1-定时">1、定时</h5>
<p>​		可以在gitlab中设置每日定时任务，定时从ldap中拉取数据到自己的数据库。</p>
<pre><code>K8S:
	这里k8s是在helm的部署文件values.yaml添加修改：
	cron_jobs:
	   ldap_sync_worker:
         cron: &quot;30 1 * * *&quot;
       ldap_group_sync_worker:
         cron: &quot;0 * * * *&quot;
二进制部署：
	请查看官方文档：https://docs.gitlab.cn/jh/administration/auth/ldap/ldap_synchronization.html

</code></pre>
<h5 id="2-手动拉取">2、手动拉取</h5>
<pre><code>手动拉取使用gitlab-rake gitlab:ldap:check命令就可以，这个是测试ladp的命令，测试的同时会拉取一遍数据。
如果是k8s需要在gitlab-toolbox容器中执行该命令
</code></pre>
<h1 id="mindoc-for-ldap">mindoc for ldap</h1>
<p>mindoc是一款开源wiki服务，由于比较冷门，后面可能几乎用不到，这里就简略记录一下，直接贴上配置文件</p>
<pre><code>app.conf #mindoc配置文件
     #是否启用ldap
    ldap_enable=true
    #ldap主机名
    ldap_host=192.168.110.29
    #ldap端口
    ldap_port=30389
    #ldap内哪个属性作为用户名
    ldap_attribute=uid
    #搜索范围
    ldap_base=dc=finsiot,dc=com
    #第一次绑定ldap用户dn
    ldap_user=cn=admin,dc=finsiot,dc=com
    #第一次绑定ldap用户密码
    ldap_password=123456
    #自动注册用户角色：0 超级管理员 /1 管理员/ 2 普通用户
    ldap_user_role=2
    #ldap搜索filter规则,AD服务器: objectClass=User, openldap服务器: objectClass=posixAccount ,也可以定义为其他属性,如: title=mindoc
    ldap_filter=objectClass=posixAccount

</code></pre>
<p>直接配置好重启应用就可以使用ldap账号登录了。</p>
<h1 id="zentao-for-ldap">zentao for ldap</h1>
<p>禅道服务接入ldap</p>
<h2 id="ldap插件部署">ldap插件部署</h2>
<p>禅道本身不支持ldap，需要额外安装ldap插件。插件地址：https://github.com/yihoyoung/zentao-ldap</p>
<p><strong>需要注意的是目前这个版本最高仅支持禅道12，本人测试在禅道18版本上面不兼容。</strong></p>
<p>其安装步骤在github的readme中有说明：</p>
<pre><code>1.打包 ldap 文件夹为 ldap.zip 文件
2.创建文件：
touch /www/zentaopms/www/ok.txt
3.admin 账户登陆禅道，后台 -&gt; 插件 -&gt; 本地安装，选择打包的 ldap.zip 文件安装即可
</code></pre>
<h3 id="具体步骤">具体步骤</h3>
<p>下载ldap代码，将这个文件打包成zip。</p>
<figure data-type="image" tabindex="17"><img src="https://koko-club.github.io/post-images/ldap/image-20230213152207304.png" alt="image-20230213152207304" loading="lazy"></figure>
<p>在服务器上面创建该文件：touch /www/zentaopms/www/ok.txt</p>
<p>然后登录禅道管理员账号，部署插件如下：</p>
<figure data-type="image" tabindex="18"><img src="https://koko-club.github.io/post-images/ldap/image-20230213152502090.png" alt="image-20230213152502090" loading="lazy"></figure>
<p>安装文件时提示版本不兼容点击强制安装即可。</p>
<figure data-type="image" tabindex="19"><img src="https://koko-club.github.io/post-images/ldap/image-20230213152747071.png" alt="image-20230213152747071" loading="lazy"></figure>
<p>安装成功以后后台会有ldap配置项：</p>
<figure data-type="image" tabindex="20"><img src="https://koko-club.github.io/post-images/ldap/image-20230213140948096.png" alt="image-20230213140948096" loading="lazy"></figure>
<h2 id="ldap配置说明">ldap配置说明</h2>
<pre><code>LDAP服务器: ldap地址
协议版本： 默认填写3
BindDN： 管理账号地址
BindDN 密码:	管理账户密码
BaseDN: 用户地址
Search filter: 搜索用户的条件，openldap这个服务默认是objectClass=posixAccount，不同的ldap服务不一样
账号字段: 登录用户名字段
EMail 字段: 邮箱字段
姓名字段: 名字字段
</code></pre>
<p>ldap配置完以后先点击保存配置，然后点击手动同步，如果有同步的用户信息那就表示没问题了。</p>
<figure data-type="image" tabindex="21"><img src="https://koko-club.github.io/post-images/ldap/image-20230213153228070.png" alt="image-20230213153228070" loading="lazy"></figure>
<p>最后在组织-》用户中查看已经通过ldap导入的用户信息。</p>
<p>注意：配置了ldap以后系统原账号登录需要在用户名前面加上“<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">”</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">号</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">例</mi><mi mathvariant="normal">如</mi></mrow><annotation encoding="application/x-tex">”符号，例如</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">”</span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">号</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">例</span><span class="mord cjk_fallback">如</span></span></span></span>admin。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://koko-club.github.io/post/hello-gridea/</id>
        <link href="https://koko-club.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="https://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>