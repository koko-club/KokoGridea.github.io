{"posts":[{"title":"欢迎来到Gridea","content":"当你看到这篇文章，意味着你的眼睛是睁开的，谢谢。","link":"https://koko-club.github.io/post/huan-ying-lai-dao-gridea/"},{"title":"jenkins","content":"jenkins介绍Jenkins是一个开源的、提供友好操作界面的持续集成(CI)工具，起源于Hudson，主要用于持续、自动的构建/测试软件项目、监控外部任务的运行。Jenkins用Java语言编写，可在Tomcat等流行的servlet容器中运行，也可独立运行。通常与版本管理工具(SCM)、构建工具结合使用。常用的版本控制工具有SVN、GIT，构建工具有Maven、Ant、Gradle。jenkins官网：https://www.jenkins.io/持续集成CI持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。通俗来讲持续集成就是软件开发人员提交代码以后自动化构建、发布、测试。持续交付CDCD(ContinuousDelivery，中文意思持续交付)是在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境(类生产环境)中。比如，我们完成单元测试后，可以把代码部署到连接数据库的Staging环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境。下图反应的是CI/CD的大概工作模式。部署部署方式一般现在就分为二进制部署和docker(k8s)部署。官网下载：https://www.jenkins.io/download/二进制包部署jenkins本身是基于java开发，其二进制包是war文件，运行于tomcat。1.部署tomcat2.下载jenkins的war部署包3.将包放于tomcat的webapps目录下，启动tomcat。默认8080端口访问。k8s(docker)部署docker部署dockeruhb官网镜像地址：https://hub.docker.com/r/jenkins/jenkins1.拉取镜像dockerpulljenkins/jenkins2.在本地创建Jenkins-home目录：mkdir-p/home/jenkins_home用于映射3.启动Jenkins容器：dockerrun-d--namejenkins-p8080:8080-p50000:50000-v/home/jenkins_home:/var/jenkins_homejenkins/jenkins​-p50000:50000，这个端口映射要保持一致，否则agent无法启动，agent部分主要作用就是告诉Jenkins,选择哪台节点机器去执行Pipeline代码4、然后网站上输入IP:8080访问，需要输入密码，复制页面上的路径，在服务器上输入cat路径查看密码，粘贴到输入框之后下一步就好​cat/var/jenkins_home/secrets/initialadminpasswordk8s部署k8s上面一般有两种部署方式，使用yaml文件部署和helm方式部署。helm方式helm方式建议使用官方镜像，这里如果用的是bitnami的镜像则建议替换成官方，我这边使用发现bitnami的jenkins有些系统配置无法持久化。helmrepoaddjenkinshttps://charts.jenkins.iohelmpulljenkinshttps://charts.jenkins.iotar-xvfjenkins-VERSION.tar.gzcdjenkinsvimvalues.yaml#根据需求更改配置重要的配置包括jenkins密码，svc类型，jenkins持久化存储配置（PVC）改完以后helminstalljenkins.-n要部署的名称空间yaml部署jenkins.yaml:apiVersion:apps/v1kind:Deploymentmetadata:name:jksspec:replicas:1selector:matchLabels:app:jkstemplate:metadata:labels:app:jksspec:containers:-name:jksimage:jenkins/jenkins:2.319.3-centos7-jdk8imagePullPolicy:Alwaysports:-containerPort:8080volumeMounts:-name:jks-homemountPath:/var/jenkins_home-name:time-zone#容器内挂载点名称mountPath:/etc/localtime#容器内挂载点路径，可以是文件或目录affinity:#这里由于jenkins镜像很大，避免删掉pod重构切换节点又要拉取数据，所以固定其节点。nodeAffinity:requiredDuringSchedulingIgnoredDuringExecution:nodeSelectorTerms:-matchExpressions:-key:kubernetes.io/hostname#标签键名operator:Invalues:-node2initContainers:-args:--c-chmod755/var/jenkins_home&amp;&amp;chown1000:1000/var/jenkins_home###这里将上一步所记录的权限属组进行更改command:-/bin/shimage:centosimagePullPolicy:IfNotPresentname:chauthsecurityContext:privileged:true###建议开启特权模式volumeMounts:-mountPath:/var/jenkins_home###initc也要对次数据卷进行挂载name:jks-homevolumes:-name:time-zone#数据卷名称，需要与容器内挂载点名称一致hostPath:path:/etc/localtime-name:jks-homepersistentVolumeClaim:claimName:jks-pvc---apiVersion:v1kind:PersistentVolumeClaimmetadata:name:jks-pvcspec:accessModes:-ReadWriteOnceresources:requests:storage:200Gi---apiVersion:v1kind:Servicemetadata:name:jksspec:selector:app:jkstype:NodePortports:-port:8080targetPort:8080nodePort:32089kubectlapply-fjenkins.yaml部署完后访问jenkins:这里还是和上面一样，进入容器找到这个文件[root@node1jenkins_test]#kubectlexec-itjks-698b6564fb-5692t-nk3s-testbashkubectlexec[POD][COMMAND]isDEPRECATEDandwillberemovedinafutureversion.Usekubectlexec[POD]--[COMMAND]instead.Defaultedcontainer&quot;jks&quot;outof:jks,chauth(init)bash-4.2$cat/var/jenkins_home/secrets/initialAdminPassword54c0b40b20f34b4ca7b75840c68883a1然后填入管理员密码就ok安装的插件如果不知道可以先选择推荐安装的插件任务jenkins主要就是通过执行任务来工作的，左边菜单第一个按钮就是新建item主要使用的就是自由项目、流水线、多分支流水线，而从任务类型角度来讲主要就分为两种：流水线与非流水线非流水线（自由风格）一般任务的步骤分为：推送代码-》触发钩子-》jenkins任务执行-》拉取代码-》构建操作-》构建后操作（一般是通知）拉取代码这里从拉取代码开始：首先在创建freestyleproject前需要先下载GitParameter模块，在系统管理—》插件管理—》可选插件中搜索gitparameter，下载并重启jenkins。新建任务在源码管理中选择git，RepositoryURL输入git仓库地址，Credentials添加一个全局凭据用于git登录，指定分支中选择要拉取的分支。构建触发器构建触发器一般用于在代码仓库推送代码之后，触发触发器然后jenkins开始构建对应的任务。这个需要GenericWebhookTrigger插件，安装完毕重启即可。webhook触发jenkins任务配置首先需要在jenkins任务中配置触发器例如这里的token设置的是test，则触发器url为：http://jenkins/generic-webhook-trigger/invok?token=test一般代码仓库如gitlab都会在具体项目里面有webhook配置，如下首先将刚刚设置拿到的触发器url填入这个URL中，然后设置触发的动作，一般pushevents即可，表示其收到push操作时，则会触发。到这里webhook触发器就配置完成了，当gitlab推送代码时，jenkins会立即执行对应项目的任务。构建环境构建环境主要构建前的一些操作，例如构建前删除工作区文件、使用密码文件或文本、如果卡住则终止构建等。这个配置不是必要配置，一般不用对构建环境做配置。构建构建最常用的就是执行shell命名，拉取代码以后的编译-》打包推送docker镜像（如果不打包就是二进制部署）-》部署操作都在这一步完成。​直接在里面执行shell命令或者执行脚本就行了。构建后操作构建后常用配置是构建通知，一般常用的是email通知，jenkins默认支持email通知但现在比较流行用webhook进行通知，jenkins默认不支持这种配置，需要额外下载插件。企业微信通知1、在需要发送企业微信通知的群中“添加群机器人”，得到webhook地址2、在Jenkins系统管理-插件管理-可选插件，搜索&quot;QyWechatNotificationPlugin&quot;插件，下载并重启Jenkins3、配置系统配置​输入webhook地址，点击保存填入webhook即可，其他几项非必填项。钉钉通知1、打开钉钉，进入群设置-智能群助手-添加机器人-自定义机器人（填写机器人名称、安全设置、协议）得到webhook2、在Jenkins系统管理-插件管理-可选插件，搜索“DingTalk”，下载并重启Jenkins3、配置系统配置进入系统管理-系统配置-钉钉，输入webhook地址、id、名称，主要是webhook地址以及钉钉那边机器人是否配置了关键字和加密，如果有需要输入然后在任务配置中最上面就可以找到钉钉机器人如果不填写内容则为插件默认的告警模式，如需自定义需要看插件文档。maven任务如果是java项目，可以使用maven风格来创建任务。首先需要按MavenIntegrationplugin插件，安装后重启在创建任务时就可以看到选项maven风格项目主要是多了一个build选项，可以直接在配置中指定pom.xml进行maven打包，不像自由风格一样所有操作都需要通过shell来执行。这里需要安装maven工具，如果没有则会提示找不到工具，需要在全局工具配置中安装或指定工具目录。流水线（pipeline）流水线其实就是通过pipeline的方式来配置任务流程。pipeline语法pipeline示例示例1pipeline{agentanystages{stage('获取代码'){steps{checkout([$class:'GitSCM',branches:[[name:'*/master']],doGenerateSubmoduleConfigurations:false,extensions:[],submoduleCfg:[],userRemoteConfigs:[[credentialsId:'4dc04ffd-15bf-46e3-a942-2b58f37bc26b',url:'git@gitlab.zhangxianwei.com:dev/java.git']]])}}stage('代码检测'){steps{echo&quot;sonarqubecheck....&quot;}}stage('代码构建'){steps{echo&quot;mavenbuild.....&quot;}}stage('代码部署'){steps{echo&quot;echosh&quot;//sh-x'/server/scripts/deploy_html_tag.sh'}}}}java项目构建pipeline示例pipeline{agent{label&quot;edge-node&quot;}options{buildDiscarder(logRotator(numToKeepStr:'3'))disableConcurrentBuilds()}stages{stage('Check'){steps{sh&quot;mvnsonar:sonar&quot;}}stage('Clean'){steps{sh&quot;mvnclean&quot;}}stage('Build'){steps{sh&quot;mvncompile&quot;}}stage('Package'){steps{sh&quot;mvnpackage-Dmaven.test.skip=true-P&quot;+env.BRANCH_NAME}}stage('Deploy'){steps{sh&quot;mvndeploy-Dmaven.test.skip=true-P&quot;+env.BRANCH_NAME}}stage('IN'){steps{sh&quot;~/kubectl_update.sh${env.WORKSPACE}${env.JOB_NAME}&quot;}}}post{success{dingTalk(robot:'jenkins',type:'MARKDOWN',title:&quot;构建成功:${JOB_NAME}&quot;,text:[&quot;##[${JOB_NAME}](${JOB_URL})&quot;,&quot;---&quot;,&quot;-任务:[${BUILD_DISPLAY_NAME}](${BUILD_URL})&quot;,&quot;-状态:&lt;fontcolor=green&gt;成功&lt;/font&gt;&quot;,&quot;-持续时间:${currentBuild.durationString}&quot;,],)}failure{dingTalk(robot:'jenkins',type:'MARKDOWN',title:&quot;构建失败:${JOB_NAME}&quot;,text:[&quot;##[${JOB_NAME}](${JOB_URL})&quot;,&quot;---&quot;,&quot;-任务:[${BUILD_DISPLAY_NAME}](${BUILD_URL})&quot;,&quot;-状态:&lt;fontcolor=red&gt;失败&lt;/font&gt;&quot;,&quot;-持续时间:${currentBuild.durationString}&quot;,],)}}}前端项目构建pipeline示例pipeline{agent{label&quot;edge-node&quot;}stages{stage('Check'){steps{sh&quot;~/sonar-scanner-4.7.0.2747-linux/bin/sonar-scanner-Dsonar.login=admin-Dsonar.password=finsi0t.c0m&quot;}}stage('Clean'){steps{sh&quot;npmcacheclean--force&quot;}}stage('Build'){steps{sh&quot;npminstall&amp;&amp;npmrunbuild:pro&quot;}}stage('Install'){steps{sh&quot;~/kubectl_update.sh${env.WORKSPACE}${env.JOB_NAME}&quot;}}}options{buildDiscarder(logRotator(numToKeepStr:'3'))disableConcurrentBuilds()}post{success{dingTalk(robot:'jenkins',type:'MARKDOWN',title:&quot;构建成功:${JOB_NAME}&quot;,text:[&quot;##[${JOB_NAME}](${JOB_URL})&quot;,&quot;---&quot;,&quot;-任务:[${BUILD_DISPLAY_NAME}](${BUILD_URL})&quot;,&quot;-状态:&lt;fontcolor=green&gt;成功&lt;/font&gt;&quot;,&quot;-持续时间:${currentBuild.durationString}&quot;,],)}failure{dingTalk(robot:'jenkins',type:'MARKDOWN',title:&quot;构建失败:${JOB_NAME}&quot;,text:[&quot;##[${JOB_NAME}](${JOB_URL})&quot;,&quot;---&quot;,&quot;-任务:[${BUILD_DISPLAY_NAME}](${BUILD_URL})&quot;,&quot;-状态:&lt;fontcolor=red&gt;失败&lt;/font&gt;&quot;,&quot;-持续时间:${currentBuild.durationString}&quot;,],)}}}创建流水线项目这里pipeline有两种方式，一种是直接在jenkins上面写，还有一种是来自仓库的pipeline文件，如上图。默认脚本文件路径是代码项目根目录下的Jenkinsfile。下面是我这里gitlab存放的用于测试的jenkinsfile：jenkinsfile(pipeline)和jenkins流水线配置完成之后就可以执行任务了。需要注意的是这里的git拉取仓库只能写在pipeline中，不能像自由风格和maven风格任务一样在任务配置中设置源码管理（git）。这里钩子触发的配置和上面一样，但构建后通知是写在pipeline中的，下面的多分支流水线会写。jenkins中的流水线语法生成器如果不熟悉流水线语法可以在配置任务中选择流水线语法，跳转到语法生成器。例如我这里生成一个git拉取代码的pipeline片段多分支流水线多分支流水线和流水线不同的地方是多分支流水线可以直接对一个项目多个分支进行任务。在实际中，需要多分支同时进行开发。如果每个分支都创建一个Jenkins项目，比较多余。一般企业生产中也会采用这种方式。新建任务中选择多分支流水线分支源配置填入git项目地址以及登录凭据，添加行为cleanbefore/aftercheckout用于清理未跟踪的文件buildconfiguration如果是仓库根目录下的jenkinsfile就用默认即可，需要注意的是项目下需要执行jenkins任务的分支都需要有jenkinsfile，每个分支的jenkinsfile是独立的。扫描多分支流水线触发器多分支流水线钩子触发器需要下载插件：MultibranchScanWebhookTrigger。安装完以后在扫描多分支流水线触发器中选择scanbywebhook，输入triggertoken。例如这里输入的是test，则gitlab那边设置触发钩子配置的url就应该是http(s)😕/JENKINS_URL/multibranch-webhook-trigger/invoke?token=test配置完保存以后会自动开始扫描多分支由于我这里有两个分支mian、master配置了jenkinsfile，则这两个分支可以构建任务多分支和钩子触发器都配置完毕后，在git仓库那边对对应分支进行push操作，这边就会自动开始构建任务安全安全配置位于：系统配置-》安全全局配置凭据这个上面在git拉取时已经用到过了，就不详细讲述了。就是存放密钥或者账号密码的模块，在系统管理-》凭据管理中可以配置（配置任务时也可以直接添加凭据）。安全域安全域主要是定义jenkins用户的数据源，默认是Jenkins自带的用户数据库。配置路径：jenkins设置-》全局安全配置-安全域这个一般使用默认项就行，如果有ldap配置需求也可以选择ldap（用户数据使用ldap的数据库）。授权策略登录用户可以做任何事授权策略默认是“登录用户可以做任何事“，表示登录用户皆为最高权限，其中有一个子选项是”匿名用户具有可读权限“，一般会配合子选项进行使用。（登录的是管理员，不登陆就只有只读权限）任何用户可以做任何事(没有任何限制)简明知意，所有用户（包括匿名用户）都有最高权限。一般不用安全矩阵和项目矩阵授权策略根据用户或用户组授予对应权限，可以精确到具体模块权限，但一般不会使用，因为有一个更好的模块Role-BasedStrategy作为替代。Role-BasedStrategy角色授权模块，也是最常用的策略，需要先下载模块Role-basedAuthorizationStrategy。应用Role-BasedStrategy以后，选择系统管理-》安全-》ManageandAssignRoles管理角色位于系统管理-》安全-》ManageandAssignRoles-》管理角色管理角色主要的功能就是创建一个角色，并对于角色授予权限，然后将角色赋予用户或用户组Globalroles全局管理，可以对用户或组授予权限（输入用户add以后通过选择打勾授予对应模块权限，然后保存生效）。Itemroles通过项目进行授权，可以使用正则匹配。例如我这里是授予有英文字母a-z的项目权限NoderolesNoderoles在Jenkins集群环境下使用，配置不同结点的Jenkins权限。（目前没使用过，如后期有使用会补上这一块内容）分配角色分配角色也是三大块：Globalroles、Itemroles、Noderoles。分配主要就是添加用户、用户组然后勾选上面创建好的角色，此时用户、用户组则拥有了该角色的权限。备注：jenkins默认没有组选项，只能通过activedirectory或者ldap对接jenkins用户数据来使用用户组管理。其他问题k8s环境中可能出现的问题时区时区默认肯定不是国内的，最简便的解决方法是通过挂载主机（k8shostpath方法）的时区文件(/etc/localtime)解决。或者dockerfile用jenkins作为基础镜像，再加上时区修改的配置也可以。中文乱码这个是不是k8s都有可能出现这个问题，主要是主机的字符集格式需要修改为中文utf-8。如果是k8s的话需要dockerfile重新打一下镜像，改成中文utf-8，或者每次启动时安装utf-8中文并配置（一般jenkins镜像没有中文utf-8）","link":"https://koko-club.github.io/post/jenkins/"},{"title":"ldap","content":"ldap什么是ldap首先LDAP是一种通讯协议，LDAP支持TCP/IP。协议就是标准，并且是抽象的。在这套标准下，AD（ActiveDirectory）是微软出的一套实现。那AD是什么呢？暂且把它理解成是个数据库。也有很多人直接把LDAP说成数据库(可以把LDAP理解成存储数据的数据库)。像是其他数据库一样，LDAP也是有client端和server端。server端是用来存放资源，client端用来操作增删改查等操作。而我们通常说的LDAP是指运行这个数据库的服务器。可以简单理解AD=LDAP服务器＋LDAP应用。用途用于统一认证管理，统一公司内部服务账号密码。LDAP模型基本模型目录树：在一个目录服务系统中，整个目录信息集可以表示为一个目录信息树，树中的每个节点是一个条目。条目：每个条目就是一条记录，每个条目有自己的唯一可区别的名称（DN）。对象类：是某个实体类型对应的一组属性，对象类可以继承，父类的必须属性也会被继承下来。属性：描述条目的某个方面的信息，一个属性由一个属性类型和一个或多个属性值组成，属性有必须属性和非必须属性。关键字英文全称含义dcDomainComponent域名的部分，其格式是将完整的域名分成几部分，如域名为example.com变成dc=example,dc=com（一条记录的所属位置）uidUserId用户IDsongtao.xu（一条记录的ID）ouOrganizationUnit组织单位，组织单位可以包含其他各种对象（包括其他组织单元），如“oa组”（一条记录的所属组织）cnCommonName公共名称，如“ThomasJohansson”（一条记录的名称）snSurname姓，如“许”dnDistinguishedName“uid=songtao.xu,ou=oa组,dc=example,dc=com”，一条记录的位置（唯一）rdnRelativedn相对辨别名，类似于文件系统中的相对路径，它是与目录树结构无关的部分，如“uid=tom”或“cn=ThomasJohansson”dn：一条记录的详细位置。目录位置dc：一条记录所属区域(哪一颗树)。根名称ou：一条记录所属组织（哪一个分支）。组名称cn/uid：一条记录的名字/ID(哪一个苹果名字)。用户名称信息模型LDAP中，信息以树状方式进行组织的，在树状信息中的基本数据单元是条目，而每个条目由属性构成，属性中存储有属性值;命名模型即LDAP中的条目定位方式，在LDAP中每个条目均有自己的DN。DN是该条目在整个树中的唯一名称标识，如同文件系统中，带路径的文件名就是DN。功能模型在LDAP中共有四类10种操作︰查询类操作：如搜索、比较;更新类操作：如添加条目、删除条目、修改条目、修改条目名;认证类操作：如绑定、解绑定;其它操作：如放弃和扩展操作。除了扩展操作，另外9种是LDAP的标准操作﹔扩展操作是LDAP中为了增加新的功能，提供的一种标准的扩展框架，当前已经成为LDAP标准的扩展操作，有修改密码和startTLS扩展，在新的RFC标准和草案中正在增加一些新的扩展操作，不同的LDAP厂商也均定义了自己的扩展操作。安全模型安全模型主要通过身份认证、安全通道和访问控制来实现。ldapserver一般ldap服务端比较常用的是openldap，这里仅记录openldap的部署及使用。openldapk8s部署直接用yaml部署就行，镜像用的是bitnami的ldap镜像apiVersion:apps/v1kind:Deploymentmetadata:name:openldapspec:replicas:1selector:matchLabels:app:openldapstrategy:rollingUpdate:maxSurge:25%maxUnavailable:25%type:RollingUpdatetemplate:metadata:labels:app:openldapspec:containers:-env:-name:LDAP_ADMIN_USERNAMEvalue:admin-name:LDAP_ADMIN_PASSWORDvalue:&quot;123456&quot;-name:LDAP_USERSvalue:manager-name:LDAP_PASSWORDSvalue:&quot;123456&quot;-name:LDAP_ROOTvalue:dc=finsiot,dc=comimage:bitnami/openldap:latestimagePullPolicy:Alwaysname:openldapports:-containerPort:1389name:serviceprotocol:TCPresources:limits:cpu:&quot;1&quot;memory:2Girequests:cpu:&quot;1&quot;memory:2GivolumeMounts:-mountPath:/bitnami/openldap/dataname:openldap-pvcsubPath:ldap-mountPath:/bitnami/openldap/slapd.dname:openldap-pvcsubPath:slapd.ddnsPolicy:ClusterFirstrestartPolicy:AlwaysschedulerName:default-schedulersecurityContext:{}terminationGracePeriodSeconds:30volumes:-name:openldap-pvcpersistentVolumeClaim:claimName:ldap-pvc---apiVersion:v1kind:PersistentVolumeClaimmetadata:name:ldap-pvclabels:app:ldapspec:storageClassName:csi-rbd-sc#这里的storageclass是我们之前申请的accessModes:-ReadWriteOnceresources:requests:storage:2Gi---apiVersion:v1kind:Servicemetadata:name:openldapspec:#clusterIP:192.168.110.29#externalTrafficPolicy:Clusterports:-nodePort:30300port:1389protocol:TCPtargetPort:serviceselector:app:openldapsessionAffinity:Nonetype:NodePortstatus:loadBalancer:{}ldap二进制部署这里没有尝试过二进制部署ldap，后面会写。ldap管理管理操作ldap数据可以使用ldap客户端或者ldap管理服务工具实现。如果使用ldapwindows客户端可以下载LDAPSoftLdapBrowser使用，如果使用管理web页面可以部署服务：ldapphpadmin。ldapphpadmink8s部署apiVersion:apps/v1kind:Deploymentmetadata:annotations:kompose.cmd:komposeconvert-fdocker-compose.ymlkompose.version:1.16.0(0c01309)creationTimestamp:nulllabels:io.kompose.service:phpldapadminname:phpldapadminspec:replicas:1strategy:{}selector:#定义选择器matchLabels:#匹配上面的标签io.kompose.service:phpldapadmin#匹配模板名称template:metadata:creationTimestamp:nulllabels:io.kompose.service:phpldapadminspec:containers:-env:-name:PHPLDAPADMIN_HTTPSvalue:&quot;false&quot;-name:PHPLDAPADMIN_LDAP_HOSTSvalue:'ldap://192.168.110.29:30389'image:osixia/phpldapadmin:0.7.1name:phpldapadminports:-containerPort:80resources:{}restartPolicy:Always---apiVersion:v1kind:Servicemetadata:ZZlabels:io.kompose.service:phpldapadminname:phpldapadminspec:ports:-name:&quot;8080&quot;port:8080targetPort:80selector:io.kompose.service:phpldapadminldapfornexus本文主要为nexus集成到ldap的配置，由于网上关于该功能的配置大都层次不齐且写的太模糊，故记录此文档。1、ldap配置这里ldap用的是openldap，所以首先需要部署好openldap。首先想要在nexus中集成ldap，ldap的服务端必须要有组和用户。这里的组用来映射与nexus的角色，使其组下面的用户都拥有nexus映射角色的权限，无需额外配置。这里的用户则用来登录nexus。所以需要创建好组和用户，这里以映射一个nexus管理员为例子，首先创建准备好ldap的用户和组：创建一个ou为nexus，组为manager，用户为nexus，先创建组，然后创建用户指定组。组:cn=manager,ou=nexus,dc=finsiot,dc=com用户:cn=nexus,ou=nexus,dc=finsiot,dc=com2、nexus配置1.访问nexus-web管理页面，登录管理员账号，进入设置-》secruity-》LDAP-》createconnection2.connection配置：name：这个是要创建的ldap名称，可以随便填，非关键性参数。Ldapserveraddress:填入ldap地址SearchbaseDn:填入dn地址（dc的地址）Authenticationmethod:SimpleAuthenticationUsernameorDN:填入登录用户名(一般用admin管理员登录)password:密码3.Userandgroup配置：configurationtemplate:选择一个模板，非关键性参数，只是会预先给出下面一些参数的值。这里可以选posixwithstaticgroupsuserrelativedn(basedn):对应于用作用户条目基础的专有名称集合。此DN与前面的searchbase相关。例如，如果用户都包含在ou=nexus，dc=finsiot,dc=com中，前面登录时指定了dc=finsiot,dc=com的搜索库，则这里使用值ou=nexus。Usersubtree：如果基本DN下面的树可以包含用户条目，则值为true;如果所有用户都包含在指定的基本DN中，则为false。例如，如果所有用户都在ou=users，dc=sonatype，dc=com，则此字段应为False。如果用户可以在组织单位内的组织单位中显示，例如ou=development，ou=users，dc=sonatype，dc=com，则此字段应为True。Objectclass：此值是RFC-2798中定义的标准对象类。它为用户指定对象类。常见值为inetOrgPerson，person，user或posixAccount。这里使用模板默认的posixAccountUserfilter：这允许您配置过滤器以限制对用户记录的搜索。它可以用作性能改进。这里不用填写。UserIDattribute：这是上面指定的对象类的属性，它从LDAP服务器提供用户的标识符。存储库管理器使用此属性作为用户ID值。在ldap创建了用户以后，里面有一个属性值（默认为uid），例如我这里创建了一个nexus的用户，则会有一个uid的值为nexus，nexus服务需要通过这个key:value来找到该用户Realnameattribute：这是Object类的属性，它提供用户的真实姓名。存储库管理器在需要显示用户的真实姓名时使用此属性，类似于内部名字和姓氏属性的使用。这个也是去找ldap里面的kv属性，默认是key的名称为cn。Emailattribute:同上面的UserIDattribute和Realnameattribute，默认key的名称为mail。Passwordattribute:不用填写，这里为空则会在登录时读取ldap中用户的password字段。MapLDAPgroupsasroles：这里需要勾选，下面是组的配置，用于将ldap组映射于nexus。Grouptype:staticGroups这里选择静态组GrouprelativeDN:指名组的DN位置，例如我这里manager组在nexus下面，则这里填ou=nexus。Groupsubtree:勾选，表示是位于group下面的子组。例如我上面ou=nexus，则这里勾选的意思是nexus下面的组。Groupobjectclass:组创建时会有这个字段，默认为posixGroup。和上面定义UserIDattribute和Realnameattribute和Emailattribute是一样的。GroupIDattribute：这里表示组的id属性，和上面定义UserIDattribute和Realnameattribute和Emailattribute是一样的。Groupmemberattribute:这里表示组里面有哪些成员，和上面两个属性一样，也是ldap组中的字段，但默认不会创建这个字段，请手动创建memberUid的字段并把成员的字段值写入该字段，否则会找不到映射的角色。Groupmemberformat:该字段用来找到memberUid中的组员名称的，使用变量${username}。创建角色在nexus设置-》security-》roles中添加一个role，type为externalrolemapping，externalroletype为ldap。MappedRole：请填写为ldap中创建的组名称，两个服务会通过名称进行映射，例如我这里ldap中有一个nexus用户，在manager组下面，于是这里我定义一个mappedrole为manager，则nexus以及ldap中manager组中所有用户都会拥有这里定义好的权限，也就是组权限映射。RoleName：role角色的名称。RoleDescription：角色介绍。Privileges：定义的是角色的权限。Roles：可以与其它定义好的role关联权限。测试创建好以后回到刚刚的ldap设置，点击刚刚创建的ldap，进入userandgroup设置，最下方有一个verifyusermapping。点击属于ldap密码就可以看到目前定义映射的组和用户情况这里userid其实就是上面useridattribute配置，name为Realnameattribute配置，email为Emailattribute，roles是MapLDAPgroupsasroles及下面所有组配置定义的。如果有没有数据的字段，请检查该项对应配置的字段是否正常配置，例如如果roles没有，请看一下MapLDAPgroupsasroles下面的配置是否正确。ldapforjenkinsjenkins集成ldap的方法1、安装插件2、配置ldap进入管理设置（managejenkins）-&gt;全局安全设置(configureglobalsecurity),设置安全域为ldap配置项Server：ldap的地址urlrootDN：根DN目录路径Usersearchbase：查找用户的目录Usersearchfilter：查找用户的条件Groupsearchbase：查找用户组的目录Groupsearchfilter：用户组条件(查找用户的条件)Groupmembership：选择SearchforLDAPgroupscontaininguserManagerDN：管理员所在路径ManagerPassword：管理员密码DisplayNameLDAPattribute：jenkins对应ldap用户名的字段EmailAddressLDAPattribute：email字段配置示例：这里ldap的结构为，用户目录：ou=people,dc=xxx,dc=com，用户组目录：ou=group,dc=xxx,dc=com这里需要注意的点是：usersearchfilter用于找到用户，如果这里填错了将会找不到用户。groupsearchbase则是用于找到用户组，如果这里填错了将找不到用户，而searchfilter用于找到用户组中的用户(&amp;(objectClass=posixGroup)(memberUid={1}))，这里的用户组主要用于授权时使用，对组进行授权。测试配置完成可以点击testldapsettings测试一下：ldapforgitlabgitlab并不能直接通知页面设置来对接ldap，而是通过配置文件。1、ldap配置（二进制部署）这里配置分为两种：一种是二进制包部署的gitlab，这个由于我并没有部署过，所以下面的配置摘抄于网上，不清楚版本有没有配置变化，但配置大致的字段基本应该是一致的；还有一种方法是k8s的配置，这种也是目前我在使用的方式，会在下面列出来。如果是二进制部署的则直接更改配置文件vi/etc/gitlab/gitlab.rbgitlab_rails['ldap_enabled']=truegitlab_rails['prevent_ldap_sign_in']=falsegitlab_rails['ldap_servers']={'main'=&gt;{'label'=&gt;'LDAP',#随便自定义'host'=&gt;'10.0.20.19',#ldap的server地址'port'=&gt;389,#ldap端口'uid'=&gt;'cn',#配置为cn或者sn都可以，但要注意用户名称将会以此处配置为依据'bind_dn'=&gt;'cn=admin,dc=aihelp,dc=net',#管理员账号'password'=&gt;'123456',#管理员密码'encryption'=&gt;'plain',#加密'allow_username_or_email_login'=&gt;false,#是否启用邮件作为用户名登陆'block_auto_created_users'=&gt;false,'base'=&gt;'dc=aihelp,dc=net',#核心配置，表示从哪一层读取用户信息'user_filter'=&gt;'(memberof=cn=jenkins,ou=group,dc=aihelp,dc=net)',#LDAP用户进行过滤'lowercase_usernames'=&gt;false,'group_base'=&gt;'','admin_group'=&gt;'','external_groups'=&gt;[],'sync_ssh_keys'=&gt;false}}其中：label是显示在GitLab登录框的上方文字描述。host和port是LDAP服务的主机地址及端口bind_dn和password是一个管理LDAP的dn及密码base表示LDAP将以该dn为节点，向下查找用户user_filter表示以某种过滤条件筛选用户，比如假设我们只希望所属组为java-platform的用户来访问GitLab，则可以在这里设置(memberOf=ou=java-platform,ou=people,dc=domain,dc=com)配置添加之后，依旧像安装时候那样，重载一下配置：gitlab-ctlreconfigureCheckingLDAP...LDAP:...Server:ldapmainLDAPauthentication...SuccessLDAPuserswithaccesstoyourGitLabserver(onlyshowingthefirst100results)DN:uid=test01,ou=people,dc=eryajf,dc=netcn:ceshiDN:uid=test02,ou=people,dc=eryajf,dc=netcn:test02DN:uid=test03,ou=people,dc=eryajf,dc=netcn:test03DN:uid=admin,ou=people,dc=eryajf,dc=netcn:AdminCheckingLDAP...Finished使用ldap用户名密码进行登陆即可，此时登陆进去是没有任何项目的权限，如果需要某权限，可以对用户进行组或者单项目的授权。2、ldap配置(k8s)ldap这里直接用helm的values.yaml传递配置文件信息，所以在ldap中配置就行了。这里如果是部署也建议采用helm部署，由于gitlab新版本模块过多，如果写yaml文件的话再加上配置文件和需要持久化的存储路径很麻烦，所以使用helm是比较理想的方式。values.yaml:----ldap:#preventtheuseofLDAPforsign-inviaweb.preventSignin:falseservers:main:label:'LDAP'host:'192.168.110.29'#ldap地址port:30389#端口uid:'uid'bind_dn:'cn=admin,dc=finsiot,dc=com'#管理员路径password:#管理员密码secret:my-ldap-password-secretkey:the-key-containing-the-passwordencryption:'plain'base:'ou=people,dc=finsiot,dc=com'#用户路径verify_certificates:true#忽略证书active_directory:falseallow_username_or_email_login:true#支持邮件和用户名登录block_auto_created_users:falseuser_filter:''attributes:username:['cn']#用户名对应ldap字段email:['mail','email']#邮箱对应ldap字段name:'description'#用户显示名字对应ldap字段fister_name:'givenName'last_name:'sn'需要注意的是，gitlab-ce仅支持ldap的用户配置，不支持ldap用户组的配置，如果想要使用ldap用户组，需要使用gitlab-ee（商业版本）。ldap的配置文件是configmap：gitlab-webservice下面的gitlab.yml.erb，挂载于gitlab-webservice-default的/var/opt/gitlab/templates/gitlab.yml.erb路径。gitlab拉取ldap账号数据问题ldap与应用结合一般有两种，一种是服务需要登录时去调用ldap的账号数据实现结合，还有一种是服务预先将ldap存在自己数据库中然后通过ldap的账号进行登录。而gitlab则是后者，这种情况会导致新加了账号但是ldap却没办法直接用新账号登录，因为gitlab并非是登录直接去ldap调用，而是从自己数据库中找ldap账号数据。解决办法1、定时​可以在gitlab中设置每日定时任务，定时从ldap中拉取数据到自己的数据库。K8S:这里k8s是在helm的部署文件values.yaml添加修改：cron_jobs:ldap_sync_worker:cron:&quot;301***&quot;ldap_group_sync_worker:cron:&quot;0****&quot;二进制部署：请查看官方文档：https://docs.gitlab.cn/jh/administration/auth/ldap/ldap_synchronization.html2、手动拉取手动拉取使用gitlab-rakegitlab:ldap:check命令就可以，这个是测试ladp的命令，测试的同时会拉取一遍数据。如果是k8s需要在gitlab-toolbox容器中执行该命令mindocforldapmindoc是一款开源wiki服务，由于比较冷门，后面可能几乎用不到，这里就简略记录一下，直接贴上配置文件app.conf#mindoc配置文件#是否启用ldapldap_enable=true#ldap主机名ldap_host=192.168.110.29#ldap端口ldap_port=30389#ldap内哪个属性作为用户名ldap_attribute=uid#搜索范围ldap_base=dc=finsiot,dc=com#第一次绑定ldap用户dnldap_user=cn=admin,dc=finsiot,dc=com#第一次绑定ldap用户密码ldap_password=123456#自动注册用户角色：0超级管理员/1管理员/2普通用户ldap_user_role=2#ldap搜索filter规则,AD服务器:objectClass=User,openldap服务器:objectClass=posixAccount,也可以定义为其他属性,如:title=mindocldap_filter=objectClass=posixAccount直接配置好重启应用就可以使用ldap账号登录了。zentaoforldap禅道服务接入ldapldap插件部署禅道本身不支持ldap，需要额外安装ldap插件。插件地址：https://github.com/yihoyoung/zentao-ldap需要注意的是目前这个版本最高仅支持禅道12，本人测试在禅道18版本上面不兼容。其安装步骤在github的readme中有说明：1.打包ldap文件夹为ldap.zip文件2.创建文件：touch/www/zentaopms/www/ok.txt3.admin账户登陆禅道，后台-&gt;插件-&gt;本地安装，选择打包的ldap.zip文件安装即可具体步骤下载ldap代码，将这个文件打包成zip。在服务器上面创建该文件：touch/www/zentaopms/www/ok.txt然后登录禅道管理员账号，部署插件如下：安装文件时提示版本不兼容点击强制安装即可。安装成功以后后台会有ldap配置项：ldap配置说明LDAP服务器:ldap地址协议版本：默认填写3BindDN：管理账号地址BindDN密码:管理账户密码BaseDN:用户地址Searchfilter:搜索用户的条件，openldap这个服务默认是objectClass=posixAccount，不同的ldap服务不一样账号字段:登录用户名字段EMail字段:邮箱字段姓名字段:名字字段ldap配置完以后先点击保存配置，然后点击手动同步，如果有同步的用户信息那就表示没问题了。最后在组织-》用户中查看已经通过ldap导入的用户信息。注意：配置了ldap以后系统原账号登录需要在用户名前面加上“”符号，例如”符号，例如”符号，例如admin。","link":"https://koko-club.github.io/post/ldap/"},{"title":"Hello Gridea","content":"👏欢迎使用Gridea！✍️Gridea一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意......GithubGridea主页示例网站特性👇📝你可以使用最酷的Markdown语法，进行快速创作🌉你可以给文章配上精美的封面图和在文章任意位置插入图片🏷️你可以对文章进行标签分组📋你可以自定义菜单，甚至可以创建外部链接菜单💻你可以在Windows，MacOS或Linux设备上使用此客户端🌎你可以使用𝖦𝗂𝗍𝗁𝗎𝖻𝖯𝖺𝗀𝖾𝗌或CodingPages向世界展示，未来将支持更多平台💬你可以进行简单的配置，接入Gitalk或DisqusJS评论系统🇬🇧你可以使用中文简体或英语🌁你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力🖥你可以自定义源文件夹，利用OneDrive、百度网盘、iCloud、Dropbox等进行多设备同步🌱当然Gridea还很年轻，有很多不足，但请相信，它会不停向前🏃未来，它一定会成为你离不开的伙伴尽情发挥你的才华吧！😘Enjoy~","link":"https://koko-club.github.io/post/hello-gridea/"}]}